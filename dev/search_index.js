var documenterSearchIndex = {"docs":
[{"location":"cg/#/-Computational-Geometry-Primitives","page":"/ Computational Geometry Primitives","title":"/ Computational Geometry Primitives","text":"","category":"section"},{"location":"cg/","page":"/ Computational Geometry Primitives","title":"/ Computational Geometry Primitives","text":"The package provides some basic geometric types in the cg submodule.","category":"page"},{"location":"cg/#Package-Features","page":"/ Computational Geometry Primitives","title":"Package Features","text":"","category":"section"},{"location":"cg/","page":"/ Computational Geometry Primitives","title":"/ Computational Geometry Primitives","text":"Provides types: Point, Segment, Line, Polygon.","category":"page"},{"location":"cg/#Basic-geometric-types","page":"/ Computational Geometry Primitives","title":"Basic geometric types","text":"","category":"section"},{"location":"cg/","page":"/ Computational Geometry Primitives","title":"/ Computational Geometry Primitives","text":"Modules = [FrechetDist.cg]\nOrder   = [:type]","category":"page"},{"location":"cg/#FrechetDist.cg.Line","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Line","text":"Line in D dimensions.\n\n`p` is a point on the line and `u` is the direction vector (not\nnecessarily normalized). Parametrised as $p + ut$\n\n\n\n\n\n","category":"type"},{"location":"cg/#FrechetDist.cg.Point","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Point","text":"Point\n\nPoint in D dimensions. Implemented currently as a struct with\nStaticArray for values. It is templated, with `N` for dimension,\nand `T` for underlying type.\n\n\n\n\n\n","category":"type"},{"location":"cg/#FrechetDist.cg.Segment","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Segment","text":"Segment\n\nSpecifies a directed segment by two endpoints.\n\n\n\n\n\n","category":"type"},{"location":"cg/#Functions","page":"/ Computational Geometry Primitives","title":"Functions","text":"","category":"section"},{"location":"cg/","page":"/ Computational Geometry Primitives","title":"/ Computational Geometry Primitives","text":"Modules = [FrechetDist.cg]\nOrder   = [:function]\n","category":"page"},{"location":"cg/#FrechetDist.cg.Polygon_read_plt_orig_file","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Polygon_read_plt_orig_file","text":"Polygon_read_plt_orig_file\n\nReads a .plt file into a polygon (2d floating point).\n\n\n\n\n\n","category":"function"},{"location":"cg/#FrechetDist.cg.Polygon_split_edges-Union{Tuple{FrechetDist.cg.Polygon{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Polygon_split_edges","text":"Polygon_split_edges\n\nOutput a polygon, where each edge is split in the middle by introducing a vertex into it.\n\n\n\n\n\n","category":"method"},{"location":"cg/#FrechetDist.cg.Polygon_write_to_file-Union{Tuple{T}, Tuple{D}, Tuple{FrechetDist.cg.Polygon{D, T}, Any}} where {D, T}","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Polygon_write_to_file","text":"Polygon_write_to_file\n\nWrites a plt file of the polygon.\n\n\n\n\n\n","category":"method"},{"location":"cg/#FrechetDist.cg.Segment_get_bisection_point-Union{Tuple{T}, Tuple{D}, Tuple{FrechetDist.cg.Segment{D, T}, Any, Any}} where {D, T}","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Segment_get_bisection_point","text":"Segment_get_bisection_point -> Bool, Real, Point\n\nComputes the intersection point of the segment `seg` with the\n\nbisector plane between p and q.\n\nReturns\n\nThe first argument returns whether the segment intersects the bisector, the pramaterized location (tm), and the intersection piont itself.\n\n\n\n\n\n","category":"method"},{"location":"cg/#FrechetDist.cg.Segment_nn_point-Union{Tuple{T}, Tuple{D}, Tuple{FrechetDist.cg.Segment{D, T}, FrechetDist.cg.Point{D, T}}} where {D, T}","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.Segment_nn_point","text":"Segment_nn_point\n\nReturns the closest point on the segment s to the query point qr.\n\n\n\n\n\n","category":"method"},{"location":"cg/#FrechetDist.cg.dist_seg_nn_point-Union{Tuple{T}, Tuple{D}, Tuple{FrechetDist.cg.Point{D, T}, FrechetDist.cg.Point{D, T}, FrechetDist.cg.Point{D, T}}} where {D, T}","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.dist_seg_nn_point","text":"dist_seg_nn_point\n\nReturns the distance to the closest point lying on the segment induced by the first two points, to the query point. By avoiding creating the segment iself, it is hopeflly more efficient.\n\n\n\n\n\n","category":"method"},{"location":"cg/#FrechetDist.cg.induced_seg_nn_point-Union{Tuple{T}, Tuple{D}, Tuple{FrechetDist.cg.Point{D, T}, FrechetDist.cg.Point{D, T}, FrechetDist.cg.Point{D, T}}} where {D, T}","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.induced_seg_nn_point","text":"induced_seg_nn_point\n\nReturns the closest point to the segment induced by the first two points, to the query point. By avoiding creating the segment iself, it is hopeflly more efficient.\n\n\n\n\n\n","category":"method"},{"location":"cg/#FrechetDist.cg.point-Tuple","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.point","text":"point( args... )\n\nA flexible constructor for a point specified by the arguments. Thus point( 2.0, 3.0, 4.0 ) defined the 3d point (2.0, 3.0, 4.0). Or similarly, point( 2.0, 1.0 ) would create a 2d point.\n\n\n\n\n\n","category":"method"},{"location":"cg/#FrechetDist.cg.segs_match_price-Union{Tuple{T}, Tuple{N}, NTuple{4, FrechetDist.cg.Point{N, T}}} where {N, T}","page":"/ Computational Geometry Primitives","title":"FrechetDist.cg.segs_match_price","text":"segs_match_price\n\nThe price of matching the edge pa-pb to the edge qa-qb.\n\n\n\n\n\n","category":"method"},{"location":"low_level/#FrechetDist.jl-/-Low-level-details","page":"FrechetDist.jl / Low level details","title":"FrechetDist.jl / Low level details","text":"","category":"section"},{"location":"low_level/#Miscellaneous","page":"FrechetDist.jl / Low level details","title":"Miscellaneous","text":"","category":"section"},{"location":"low_level/","page":"FrechetDist.jl / Low level details","title":"FrechetDist.jl / Low level details","text":"We cover here a few low level internal functions. This is probably","category":"page"},{"location":"low_level/","page":"FrechetDist.jl / Low level details","title":"FrechetDist.jl / Low level details","text":"only of interest if you are trying to understand the source coe of the package.","category":"page"},{"location":"low_level/#Functions-documentation","page":"FrechetDist.jl / Low level details","title":"Functions documentation","text":"","category":"section"},{"location":"low_level/","page":"FrechetDist.jl / Low level details","title":"FrechetDist.jl / Low level details","text":"FrechetDist.extract_param_inner\nFrechetDist.extract_refined_polygon\nFrechetDist.frechet_c_mono_approx_subcurve\nFrechetDist.frechet_mono_via_refinement\nFrechetDist.frechet_ve_r_mono_compute\nFrechetDist.Morphing_from_prm\nFrechetDist.add_points_along_seg\nFrechetDist.EID\nFrechetDist.integral\nFrechetDist.SweepDist_segs\nFrechetDist.DistFunc_verify_integral\nFrechetDist.frechet_offsets\nFrechetDist.SweepDist_segs_p\nFrechetDist.integral_interval\nFrechetDist.SweepDist_lb_compute","category":"page"},{"location":"low_level/#FrechetDist.extract_param_inner","page":"FrechetDist.jl / Low level details","title":"FrechetDist.extract_param_inner","text":"extract_param_inner\n\nTakes the sequence of events (i.e., sequence of points along the curve), and outputs a corresponding sequence of real numbers, where the ith nubmer if the distance of the ith point in sequence from the beginning of the curve. Here, distance means the total distance of the subcurve from the start point, to the current point.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.extract_refined_polygon","page":"FrechetDist.jl / Low level details","title":"FrechetDist.extract_refined_polygon","text":"extract_refined_polygon( P, pes, num_points_to_add )\n\nRefine edges along which pes (the sequence of matching points\nalong P is not monotone, so that the returned polygon has\nvertices, which hopefully force the Frechet morphing computed in\nthe next iteration to be monotone.\n\nArguments\n\nP  : the polygo   pes: Sequence of events long the polygon P   num_points_to_add: how many points to add between points of                        non-monotonicity. The default is 1. Having a                        larger value speeds up the process of getting                        rid of non-monotonicity, but the polygons grow                        faster.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.frechet_c_mono_approx_subcurve","page":"FrechetDist.jl / Low level details","title":"FrechetDist.frechet_c_mono_approx_subcurve","text":"frechet_c_mono_approx_subcurve\n\nApproximates the Frechet distance between a curve (P) and subcurbe (Q). Here, Q vertices are the vertices of P specifieid by pindices. That is Q[ i ] =P[ pindices[ i ]].\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.frechet_mono_via_refinement","page":"FrechetDist.jl / Low level details","title":"FrechetDist.frechet_mono_via_refinement","text":"frechet_mono_via_refinement( P, Q, approx )\n\nComputes the \"true\" monotone Frechet distance between P and Q,\nusing the ve_r algorithm. It does refinement, to add vertices if\nneeded to get monotonicity. Note, that there is an eps parameter -\nfor real inputs you can set it quite small. In any case, in the\nworst case it only approximates the Frechet (monotone)\ndistance. It returns a morphing, and a boolean that is true if the\nresult is the true Frechet distance.\n\nObserve, that this function might be too slow if the two curves\nare huge, since it does not simplify them before computing the\ndistance.\n\nReturns\n\nReturns a 4-tuple  ( m, f, P, Q ): m: Morphing realizing result. f: Is distance returned is the exact continuous Frechet distance. P: Refined first input polygon Q: Refined second input polygon\n\n'out' if specified returns the middle morphings used in computing the       solution.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.frechet_ve_r_mono_compute","page":"FrechetDist.jl / Low level details","title":"FrechetDist.frechet_ve_r_mono_compute","text":"frechet_ve_r_mono_compute\n\nComputing the ver frechet distance, and then monotonize it. No guarentee as far as the quality of the distance this realizes...\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.Morphing_from_prm","page":"FrechetDist.jl / Low level details","title":"FrechetDist.Morphing_from_prm","text":"Morphing_from_prm( prm, P, Q )\n\nConstruct a morphing from a parameterization of the two polygons P\nand Q.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.add_points_along_seg","page":"FrechetDist.jl / Low level details","title":"FrechetDist.add_points_along_seg","text":"add_points_along_seg\n\nArguments\n\nseg: t[1], t[2], .... , t[end]\n\n t[...]: Time stamps for points on the segment (all between 0 and 1)\n\nDetails\n\nAdd points along seg at time stamps specified by t, and add points in the middle between them (i.e., refining segment). These new points are added the output polygon pout.\n\nNote, that one can set nmidpoints to be larger than 1, but it does not seem to be necessary/benefitial from the experimentation we did.\n\nOutput:      Sorted( t[1]/2, t[1], (t[1]+t[2])/2, t[2],...)\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.EID","page":"FrechetDist.jl / Low level details","title":"FrechetDist.EID","text":"EID\n\nA function that encodes a matching \"edge\" betwee two polygons.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.integral","page":"FrechetDist.jl / Low level details","title":"FrechetDist.integral","text":"intgral\n\nreturns the integral of the function f, for the value x. This integral was computed by sage math.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.SweepDist_segs","page":"FrechetDist.jl / Low level details","title":"FrechetDist.SweepDist_segs","text":"SweepDist_segs\n\nFinally, compute the CDTW between two (oriented) segmets p_a p_b and q_a q_b. Its simply the sum of teh two oriented integrals of the distance.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.DistFunc_verify_integral","page":"FrechetDist.jl / Low level details","title":"FrechetDist.DistFunc_verify_integral","text":"DistFunc_verify_integral\n\nVerifies the intergral function presented above.  Since we got the integral of the function f from software (i.e., sagemath), and I was too lazy to verify it by hand, I did a numerical verification.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.frechet_offsets","page":"FrechetDist.jl / Low level details","title":"FrechetDist.frechet_offsets","text":"frechet_offests\n\nGiven P, and subset of indices of P defining a subpolygon, computes a -approximation to the Frechet distance between every edge of the subpolygon they define, and corresponding portion of P.  A fast, and probably decent approximation to the optimal morhping. Finally, set for every vertex of the subcurve, the frechet distance of this subcurve. Thus, providing a fast estimates of the offsets.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.SweepDist_segs_p","page":"FrechetDist.jl / Low level details","title":"FrechetDist.SweepDist_segs_p","text":"SweepDist_segs_p\n\nReturn the oriented Sweep distance (i.e., continuous dynamic time wrapping) distance between two oriented segments. To this end, we compute the distance function, and then compute its integrval.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.integral_interval","page":"FrechetDist.jl / Low level details","title":"FrechetDist.integral_interval","text":"inegral_interval\n\nReturn the integral of f over an interval.\n\n\n\n\n\n","category":"function"},{"location":"low_level/#FrechetDist.SweepDist_lb_compute","page":"FrechetDist.jl / Low level details","title":"FrechetDist.SweepDist_lb_compute","text":"SweepDist_lb_compute\n\nCompute a lower bound on the Sweep distance between the two curves P and Q. Current implementation is silly, and very similar to the discrete Frechet calculation.\n\n\n\n\n\n","category":"function"},{"location":"morphing/#Morphing","page":"Morphing","title":"Morphing","text":"","category":"section"},{"location":"morphing/","page":"Morphing","title":"Morphing","text":"A *morphing* is an encoding of a \"matching\" between two curves. It\nis the output of the various Frechet distance computation functions.\nThe package provides some basic geometric types in the cg submodule.","category":"page"},{"location":"morphing/#Types","page":"Morphing","title":"Types","text":"","category":"section"},{"location":"morphing/","page":"Morphing","title":"Morphing","text":"Morphing","category":"page"},{"location":"morphing/#FrechetDist.Morphing","page":"Morphing","title":"FrechetDist.Morphing","text":"Morphing\n\nEncoding of a moprhing (i.e., matching) between two polygonal cuves.\n\n\n\n\n\n","category":"type"},{"location":"morphing/#Functions","page":"Morphing","title":"Functions","text":"","category":"section"},{"location":"morphing/","page":"Morphing","title":"Morphing","text":"Morphing_monotonize\nMorphing_empty\nMorphing_verify_valid\nMorphing_combine\nMorphing_extract_prm\nMorphing_as_polygons\nMorphing_extract_vertex_radii\nMorphing_extract_offsets","category":"page"},{"location":"morphing/#FrechetDist.Morphing_monotonize","page":"Morphing","title":"FrechetDist.Morphing_monotonize","text":"Morphing_monotonize\n\nTurns a morphing into a monotone morphing, by simply not going back, staying in place if necessary.\n\n\n\n\n\n","category":"function"},{"location":"morphing/#FrechetDist.Morphing_empty","page":"Morphing","title":"FrechetDist.Morphing_empty","text":"Morphing_empty\n\nReturns an empty morhping (i.e., a constructor).\n\n\n\n\n\n","category":"function"},{"location":"morphing/#FrechetDist.Morphing_verify_valid","page":"Morphing","title":"FrechetDist.Morphing_verify_valid","text":"Morphing_verify_valid\n\nDoes some minimal checks that the morphing is valid. Speciifcally, check the times stemps of the events are valid.\n\n\n\n\n\n","category":"function"},{"location":"morphing/#FrechetDist.Morphing_combine","page":"Morphing","title":"FrechetDist.Morphing_combine","text":"Morphing_combine\n\nGets two morphings u, v (i.e., two parameterizations) and combine them into a single morphing u(v(.)).\n\nFor example, if u: γ → δ  and  v: δ → ξ, then the returned morphing is u(v(⋅)): γ → ξ.\n\n\n\n\n\n","category":"function"},{"location":"morphing/#FrechetDist.Morphing_extract_prm","page":"Morphing","title":"FrechetDist.Morphing_extract_prm","text":"Morphing_extract_prm\n\nA parameterization is a polygonal curve that starts at (0,0) and\nend at (m,n).  The polygonal curve either have positive slope edge,\nor vertical or horizontal edges. It can be thought of as a\npiecewise linear function from [0,m] to [0,n]. Here m and n are the\nlengths of the two given polygons of P and Q, respectively.\n\n\n\n\n\n","category":"function"},{"location":"morphing/#FrechetDist.Morphing_as_polygons","page":"Morphing","title":"FrechetDist.Morphing_as_polygons","text":"Morphing_as_polygons\n\nTurns the morphing matching into a \"true\" matching, by creating two polygons that their edges are directly matched.  The output polygons P and Q will definitely have reapeated points.\n\n\n\n\n\n","category":"function"},{"location":"morphing/#FrechetDist.Morphing_extract_vertex_radii","page":"Morphing","title":"FrechetDist.Morphing_extract_vertex_radii","text":"Morphing_extract_vertex_radii\n\nComputes for each polygon vertex, the length of the longest edge\nin the matching attached ot it. It is a cheap upper bound on the\nlocal Frechet distance for each vertex (and implicitly the\nattached edge).\n\n\n\n\n\n","category":"function"},{"location":"morphing/#FrechetDist.Morphing_extract_offsets","page":"Morphing","title":"FrechetDist.Morphing_extract_offsets","text":"Morphing_extract_offsets\n\n\n\n\n\n","category":"function"},{"location":"morphing/","page":"Morphing","title":"Morphing","text":"```","category":"page"},{"location":"frechet_discrete/#Discrete-Fréchet-distance","page":"Discrete Fréchet distance","title":"Discrete Fréchet distance","text":"","category":"section"},{"location":"frechet_discrete/#Description","page":"Discrete Fréchet distance","title":"Description","text":"","category":"section"},{"location":"frechet_discrete/","page":"Discrete Fréchet distance","title":"Discrete Fréchet distance","text":"The discrete Frechet distance dells with the easier variant, where    the input is two sequence of points, and the distance is the    minimum max-leash that is needed, if two \"frogs\" jumps in a    synchronized fashion along the two sequences, starting at the start    of the sequences, and end in the end of the sequences. At each    point only one frog jumps, and it can jump only forward by one    position in the sequence of points it is on.","category":"page"},{"location":"frechet_discrete/","page":"Discrete Fréchet distance","title":"Discrete Fréchet distance","text":"The basic solution to this is dynamic programming, which is similar    in nature to edit-distance.","category":"page"},{"location":"frechet_discrete/","page":"Discrete Fréchet distance","title":"Discrete Fréchet distance","text":"We also present the retractable variant, which tries to use a leash    that is as short as possible at any point in time.","category":"page"},{"location":"frechet_discrete/","page":"Discrete Fréchet distance","title":"Discrete Fréchet distance","text":"Finally, we also present a variant for the \"continuous\" variant,    where one samples points along two polygons, and then compute their    discrete Frechet distance. This is the \"standard\" way of using the    discrete Frechet distance for the continuous problem. It provides    inferior results than the continuous variants, but it is simple    enough to implement, and it is thus provided.","category":"page"},{"location":"frechet_discrete/#Functions-documentation","page":"Discrete Fréchet distance","title":"Functions documentation","text":"","category":"section"},{"location":"frechet_discrete/","page":"Discrete Fréchet distance","title":"Discrete Fréchet distance","text":"frechet_d_compute\nfrechet_d_r_compute\nfrechet_d_r_compute_sample\nFrechetDist.DTW_d_compute\nFrechetDist.d_frechet_extract_solution","category":"page"},{"location":"frechet_discrete/#FrechetDist.frechet_d_compute","page":"Discrete Fréchet distance","title":"FrechetDist.frechet_d_compute","text":"frechet_d_compute\n\nComputes the discrete Fréchet distance between the two sequences of points. It interpresents the vertices of the polygons and the desired sequence of points.\n\n\n\n\n\n","category":"function"},{"location":"frechet_discrete/#FrechetDist.frechet_d_r_compute","page":"Discrete Fréchet distance","title":"FrechetDist.frechet_d_r_compute","text":"frechet_d_r_compute\n\nCompute discrete frechet distance that is locally optimal Frechet. Essentially discrete frechet + Prim/Dijkstra algorithm For the discrete case, that is modified to be retractable – that is minimize the maximum bottleneck edge being computed.\n\nNote, the function still allocates quadratic space for the lookup tables. Doesn't seem to matter, but this might be worth fixing in future versions.\n\n\n\n\n\n","category":"function"},{"location":"frechet_discrete/#FrechetDist.frechet_d_r_compute_sample","page":"Discrete Fréchet distance","title":"FrechetDist.frechet_d_r_compute_sample","text":"frechet_d_compute_sample\n\nComputes the discrete Frechet distance between the two curves.by sampling them\n\nIt first sapmles the two curves rougly uniformly. n is supposed to be the nubmer of vertices, by the optput might be a sample that is slightly bigger, as the code tries to ensure the vertices are being picked.\n\nArguments\n\nn: number of vertices to add when \"refining\" the two curves. The number of vertices computed might be larger (but hopefully not much larger).\nf_lopt    true: Use the rectractable Frechet distance version    false: Use the standard discrete Frechet version.\n\n\n\n\n\n","category":"function"},{"location":"frechet_discrete/#FrechetDist.DTW_d_compute","page":"Discrete Fréchet distance","title":"FrechetDist.DTW_d_compute","text":"DTW_d_compute\n\nCompute the Dynamic Time Wrapping distance between two\npolygons. Here the price is the of lengths of leashes throughtout\nthe discrete morphing.\n\n\n\n\n\n","category":"function"},{"location":"frechet_discrete/#FrechetDist.d_frechet_extract_solution","page":"Discrete Fréchet distance","title":"FrechetDist.d_frechet_extract_solution","text":"d_frechet_extract_solution\n\nExtracting the morphing computd realizing the discrete Frechet distnace.\n\n\n\n\n\n","category":"function"},{"location":"#FrechetDist.jl","page":"Home","title":"FrechetDist.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the Fréchet distance between curves.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provides algorithm for computing the discrete, VE, regular Frechet distance between polygonal curves. Supports also the retractable version.","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"frechet_c_compute\nfrechet_c_approx\nfrechet_dist_upper_bound\nFrechetDist.frechet_width_approx","category":"page"},{"location":"#FrechetDist.frechet_c_compute","page":"Home","title":"FrechetDist.frechet_c_compute","text":"frechet_c_compute\n\nCompute the exact continuous (monotone) Frechet distance between the two polygons. It should be reasonably fast.\n\nThis function is somewhat slower than the approximate versions. Use it only if you really want the exact answer. Consider using frechetcontinousapprox instead.\n\nDetails\n\nThis works by first computing a very rough approximation, followed by distance senstiave simplification of the curves. It then compute the monotone frver distance between the simplified curves, and it combine it to get a distance between the two original cuves. It makre sure the answers are the same, otherwise, it repeates with a finer simplification/approximation till they are equal.\n\nFinally, the algorithm uses the frverwithoffests distance between the two simplified curves to comptue a lower bound, and make sure this is equal to the Frechet distance computed. If they are equal, then the upper/lower bounds on the Frechet distance of the two curves are the same, which implies that the computed distance is indeed the desired Frechet distance.\n\nMore details\n\nTo really ensure converges, the monotone distance computed between the simplification is computed using refinement, so tha the ve_r distance\n\n\n\n\n\n","category":"function"},{"location":"#FrechetDist.frechet_c_approx","page":"Home","title":"FrechetDist.frechet_c_approx","text":"frechet_c_approx\n\nApproximates the continuous Frechet distance between the two input curves. Returns a monotone morphing realizing it.\n\nArguments\n\napprox : The output morhing has Frechet distance <= approx*optimal.\n\nImportantly, approx can be larger than 2, if you want a rough approximation.\n\nThe quality of approximation is available at ret.ratio. Thus, ret.leash/ret.ratio is a lower bound on the Frechet distance, while ret.leash is an upper bound.\n\n\n\n\n\n","category":"function"},{"location":"#FrechetDist.frechet_dist_upper_bound","page":"Home","title":"FrechetDist.frechet_dist_upper_bound","text":"frechet_dist_upper_bound\n\nReturns a rough upper bound on the Frechet distance between the two curves. This upper bound is on the continuous distance. No guarenteee on how bad the approximation is. This is used as a starting point for real approximation of the Frechet distance, and should not be used otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#FrechetDist.frechet_width_approx","page":"Home","title":"FrechetDist.frechet_width_approx","text":"frechet_width_approx\n\n2-approximation to the Frechet distance between    seg = P[first(rng)]-P[last(rng)] and he polygon    P[rng]  Here, rng is a range i:j\n\nThis function implements a greedy matching alnog the segment - you move to the cloest point on seg to the current point, making sure never moving back.\n\n\n\n\n\n","category":"function"}]
}
